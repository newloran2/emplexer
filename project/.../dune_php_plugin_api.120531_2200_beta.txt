======================================================================
DUNE HD STB -- PLUGINS MECHANISM AND PHP API
======================================================================

Introduction
------------

The mechanism of plugins provides a possibility to integrate applications
into the native Dune GUI. When an application is packaged as a plugin, it
can appear in the native Dune GUI just an an icon in Dune menu.

Such applications can be implemented using a variety of technologies
supported by Dune HD STB:
   - It can be a full-screen HTML application.
   - It can be a full-screen FlashLite application.
   - It can be an application based on the native Dune HD GUI framework and
     implemented using PHP language and PHP API provided by Dune HD STB.
   - It can include some web server functionality (e.g. CGI scripts running
     on the STB) providing HTTP API for external systems or providing a way
     for HTML or FlashLite application to execute native code on the STB.
   - It can include any Linux software executed on demand or running in the
     background, and it can even include custom Linux kernel modules (e.g.
     drivers for certain USB hardware or kernel modules implementing
     certain DRM systems).
   - The application can also use a mix of different technologies.

A big part of the plugins mechanism is the PHP API for implementation of
GUI functionality based on the native Dune HD GUI framework. This approach
allows quick implementation of GUI functionality tightly integrated into
the native Dune GUI. It is especially suitable for quick creation of simple
IPTV/VOD applications. The following possibilities are provided:
   - HTML coding is NOT involved; the standard GUI (native Dune HD media
     player GUI) is used automatically. The PHP code is only responsible
     for the interaction with the server part of the service (typically
     via HTTP requests), and customizing the GUI look/behavior in some
     ways.
   - OSD GUI for IPTV and VOD playback is provided automatically
     (including TV channels navigation, TV channel categories, favorite
     channels management, EPG, series navigation, etc).
   - Plugin can easily visualize hierarchical catalogs of content (TV
     channel categories, VOD categories, etc).
   - Plugin can show various user interaction dialogs (login, movie
     purchase confirmation, settings, etc).

Plugin examples
---------------

IPTV/VOD applications implemented using PHP:
   - http://files.dune-hd.com/partners/sdk/plugins/dune_plugin_ktv.2011_12_22.zip
   - http://files.dune-hd.com/partners/sdk/plugins/dune_plugin_demo2.2011_12_22.zip
   - http://files.dune-hd.com/partners/sdk/plugins/dune_plugin_demo2_with_ad.zip

Simple digital signage application (endless playback of a media_url)
implemented using PHP:
   - http://files.dune-hd.com/partners/sdk/plugins/dune_plugin_simple_presenter.2013_07_19.zip

HTML application:
   - http://files.dune-hd.com/partners/sdk/plugins/dune_plugin_html_demo.2012_11_01.zip
   - http://files.dune-hd.com/partners/sdk/plugins/dune_plugin_iptv_demo.2013_09_03.zip

Historical note
---------------

When the mechanism of plugins was first introduced in Dune HD STB, it was
originally intended for the implementation of custom GUI applications using
the provided PHP API, and it was required that each plugin included at
least some PHP code. This was the reason why plugins were originally called
"PHP plugins". Later, various features allowing to use the mechanism of
plugins w/o the need to use PHP code were added, but the term "PHP plugin"
was still used. The documentation below refers to the term "PHP plugin",
but all the features which are not directly related to the use of PHP
language are also applicable to plugins which do not actually use any PHP
code.

Implementing GUI functionality using PHP API
--------------------------------------------

The mechanism of PHP plugins allows to extend Dune GUI with custom
applications implemented using PHP programming language and PHP API
provided by Dune HD STB. PHP plugins created using this mechanism are
stored in the STB flash memory and are running on the STB.

This PHP API does not allow PHP plugins to directly render an arbitrary TV
GUI and directly handle events from the remote control in arbitrary ways.
Instead, there is a high-level GUI framework with a fixed set of
possibilities, and PHP plugins may use these possibilities for custom GUI
creation.

The main goal of the PHP plugins mechanism is to allow to implement custom
IPTV/VOD applications, but it also could be used for other similar
purposes.

The possibilities provided by the PHP plugins mechanism include:
    - Showing custom screens listing various objecs (e.g. TV channels,
      movies, categories, etc). The possibilities for the customizing the
      GUI of these screens are similar to those provided by the
      "dune_folder.txt" mechanism (see
      http://dune-hd.com/support/misc/dune_folder_howto.txt).
    - Showing "movie information" screens.
    - Showing custom screens and dialogs with some GUI controls for user
      input (e.g. text fields, buttons, etc).
    - Launching playback of TV and VOD content in a special mode (with
      special TV and VOD OSD GUI).

The advantages for implementing custom applications (e.g. custom IPTV/VOD
applications) using PHP plugins mechanism are the following:
    - Reduced implementation effort.
        - No need to implement the GUI from the scratch, a high-level GUI
          framework allows to very quickly and easily implement standard
          IPTV and VOD functionality.
        - Just feed the proper data into the GUI and everything is working
          automatically.
    - Smooth integration into Dune GUI.
        - The look and feel of the custom application is the same as the
          look and feel of other STB functions.
        - Choosing a different GUI skin automatically affects the custom
          application as well.
     - All features of Dune GUI are automatically provided for the custom
       application.
        - High-quality graphics with FullHD (1920x1080) resolution.
        - Fast GUI.
        - Animation effects.
        - GUI structure with 4 screen areas (path bar, widget zone with
          date/time and weather information, main content box, optional
          details panel at the right).
        - Ability to integrate custom screens into STB Setup menu.
    - PHP plugin is stored in the STB flash memory and runs on the STB.
        - This allows to integrate with the existing server-side IPTV
          middleware APIs, w/o the need to host anything on the web server.
        - This allows to reduce the amount of the functionality that should
          be hosted/executed on the web server.
        - This allows to implement client-side caching and improve the
          performance in other ways.

Installing PHP plugins
----------------------

One STB may have one or several PHP plugins installed. PHP plugins may be
preinstalled (included into STB firmware), or installed by the user (using
PHP plugin installer).

For manual installation of a PHP plugin, a special "plugin installer" file
is needed. The plugin installer file is just a ZIP archive containing
"dune_plugin.xml" file at the top level and other files (according to
plugins needs).

To install a PHP plugin, just launch the plugin installer file
(dune_plugin*.zip) from any media (e.g. from USB flash drive). The plugin
will be installed into the flash memory of the STB. If plugin with the same
name was already installed manually, then an option will appear allowing to
overwrite plugin or cancel installation. Note, that the preinstalled
(included into STB firmware) PHP plugins cannot be overwritten.

Note, the STB typically requires "Flash memory storage" (a special
partition in the flash memory of the STB) or "System storage" (an external
storage device used for system needs) to be activated in order to manually
install PHP plugins. If neither is activated yet, the STB will propose to
activate "Flash memory storage" during plugin installation. For more
information about "Flash memory storage" and "System storage", please see
http://dune-hd.com/support/usb_flash_drive .

PHP plugins manually installed by the user are listed in "Setup / Misc /
Plugins" menu. This menu also allows to delete the previously manually
installed plugins (select the plugin, press ENTER, choose "Delete").

Preinstalled PHP plugins (included into STB firmware) are not listed in
"Setup / Misc / Plugins" menu and can not be deleted.

Providing additional plugins via "dune_plugins" folder
------------------------------------------------------

There is a special possibility which allows to add plugins to
the list of registered plugins, using a special "dune_plugins" folder. This
folder should be located at the top-level of the "main" storage device.
This folder should contain one or several subfolders, where each subfolder
should contain the data of one plugin (i.e. the dune_plugin.xml and other
plugin data).

NOTE: In order to ensure that the storage device is recognized as the
"main" one, it should be either the only storage device connected to the
player at the moment, or the only storage device connected to the player at
the moment when the player is switched on.

NOTE: This possibility is not recommended for normal users; it is mostly
intended for the development needs (e.g. when it is needed to edit the
plugin PHP code and look at the result).
NOTE: to apply changes made in "dune_plugins" folder one should press POWER
remote button twice: first to turn STB into standby mode and second to turn
it on again.

Redirecting plugin logs to "dune_plugin_logs" folder
----------------------------------------------------

There is a special possibility which allows to redirect logs produced by
all plugins which were installed manually to the special "dune_plugin_logs"
folder. This folder should be located at the top-level of the "main"
storage device. Normally, all logs are written to some temporary folder not
accessible from the outside. If "dune_plugin_logs" exists all logs from the
non-built-in plugins will be written to this folder.

NOTE: In order to ensure that the storage device is recognized as the
"main" one, it should be either the only storage device connected to the
player at the moment, or the only storage device connected to the player at
the moment when the player is switched on.

NOTE: This possibility is not recommended for normal users; it is mostly
intended for the development needs. It is recommended to use HDD instead of
Flash drive as "main" storage device for writing logs to.

PHP plugin files structure
--------------------------

The php plugin is a folder containing the following files:

1. dune_plugin.xml (required)
    - This is plugin manifest in XML format. This is the only file required
      by the STB in order to load the plugin. All other plugin files (if
      any) are specified in the plugin manifest, and can have any names.

2. The PHP program containing hd_create_plugin() function. (required)
    - The path to the file with this PHP program is specified in
      "dune_plugin.xml".

3. Translation tables
    - The files translations/dune_language_<lang>.txt will be automatically
      loaded to the global STB translation table on STB start or when
      interface language is changed by user. The keys provided in
      translation files can be accessed using special syntax in public
      string of PHP API.
      See the "Interface language translations" section for more details.

4. Some resources accessible by HTTP in web and web/cgi-bin directories.
    - These resources will be accessible using the following url schema:
        http://<STB-address>/plugins/<plugin-name>/<path-from-www>
        http://<STB-address>/cgi-bin/plugins/<plugin-name>/<path-from-cgi-bin>
      See "HTTP server extension" section for more details.

5. Any other files, e.g. some resources (e.g. images/icons) (optional)
    - These files may be referenced by "dune_plugin.xml" or other files, or
      used in other ways by the PHP program.

Plugin manifest
---------------

The sample manifest of plugin called 'sample' may look as following:

<dune_plugin>
  <name>sample</name>
  <caption>Sample</caption>
  <type>php</type>
  <params>
     <program>sample.php</program>
  </params>
  <entry_points>
    <entry_point>
        <parent_media_url>root://tv</parent_media_url>
        <media_url>main_tv</media_url>
        <caption>Sample.TV</caption>
        <icon_url>plugin_file://icons/sample_tv.png</icon_url>
        <actions>
          <key_enter>
            <type>plugin_open_folder</type>
          </key_enter>
          <key_play>
            <type>plugin_tv_play</type>
          </key_play>
        </actions>
        <popup_menu>
          <menu_items>
            <item>
                <caption>Clear TV Cache</caption>
                <action>
                    <type>plugin_handle_user_input</type>
                    <params>
                        <op>clear_cache</op>
                    </params>
                </action>
            </item>
          </menu_items>
        </popup_menu>
        <show_default_value>yes</show_default_value>
        <show_cookie_name>show_tv_entry_point</show_cookie_name>
        <ip_address_required>yes</ip_address_required>
        <valid_time_required>yes</valid_time_required>
    </entry_point>
    <entry_point>
        <parent_media_url>root://applications</parent_media_url>
        <media_url>main_vod</media_url>
        <caption>Sample.VOD</caption>
        <icon_url>plugin_file://icons/sample_vod.png</icon_url>
        <actions>
          <key_enter>
            <type>plugin_open_folder</type>
          </key_enter>
        </actions>
        <show_default_value>yes</show_default_value>
        <show_cookie_name>show_vod_entry_point</show_cookie_name>
        <ip_address_required>yes</ip_address_required>
        <valid_time_required>yes</valid_time_required>
    </entry_point>
  </entry_points>
  <auto_resume>
     <enable>yes</enable>
     <ip_address_required>yes</ip_address_required>
     <valid_time_required>yes</valid_time_required>
  </auto_resume>
  <operation_timeout>
    <default>20</default>
    <get_epg_day>30</get_epg_day>
  </operation_timeout>
</dune_plugin>

Details:

- dune_plugin->name: plugin identifier. It should be nonempty and may
  contain only alphanumeric and ('-', '.', '_') characters. Length is
  limited by 64.

- dune_plugin->caption: caption used in Setup / Misc / Plugins

- dune_plugin->type and dune_plugin->params: the type of engine used to
  execute plugin and it's parameters. Currently only the 'php' type is
  supported having single mandatory 'program' parameter pointing to the
  main php file of plugin.

- dune_plugin->entry_points: list of the plugin entry points in the Dune
  menu. Each dune_plugin->entry_points->entry_point may contain the
  following fields:

  - 'parent_media_url': the URL of folder containing this entry
    point. Now the following folders are allowed to contain plugin
    items:
      root://tv
      root://applications
      setup://applications

  - 'caption', 'icon_url': visualization of entry point

  - 'media_url': identifier of menu node of the plugin menu hierarchy
    Identifier should be unique in scope of plugin. The 'media_url'
    will be used in some plugin operations.

  - 'actions': the event->action mapping. The list of pairs: event_id =>
    action specification. If entry point is focused and the specified key
    is pressed then the corresponding action will be executed by Dune GUI.
    See the "Plugin PHP program main features overview" section for more
    details about how the Dune GUI works with the entry points.
    See the "GUI Actions" section for more details about the concept of GUI
    action and for the list of available GUI actions.

  - 'popup_menu': the list of additional popup menu items to be addded to
    the context menu of entry point.

  - 'show_default_value' and 'show_cookie_name': this is a way for
    plugin to show/hide entry points.
      The 'show_cookie_name' is a name of plugin cookie (e.g. the
      persistent property name) whose value is used as boolean
      expression. The expression is evaluated to decide whether to
      show entry point in Dune menu. The expression syntax is the
      following:
        yes
        no
        lang(<lang1>,...,<langN>).
      The 'show_default_value' is used if 'show_cookie_name' is not
      set.

  - 'ip_address_required': yes | no. If 'yes' is specified and the IP address
    is not available yet then opening of this entry point will cause the
    WaitIpAddress dialog to appear until the IP address is got or user
    presses Cancel button or dialog is cancelled by timeout.

  - 'valid_time_required': yes | no. If 'yes' is specified and the valid time
    is not synchronized from internet yet then opening of this entry point
    will cause the WaitValidTime dialog to appear until the valid time is
    got or user presses Cancel button or dialog is cancelled by timeout.

- auto_resume: the specification of auto-resume feature which is disabled
  by default. The following fields supported:

    - enable: yes/no. This enables auto-resume feature. The default
          implementations supporting all use-cases (live TV playback,
          archive TV playback, VOD playback) will be used.

    - action: GUI action. This GUI action will be executed in case of
          auto-resume instead of the default algorithm.

    - ip_address_required: yes/no. If yes => the wait_ip_address dialog is
      shown if needed in auto-resume use-case.

    - valid_time_required: yes/no. If yes => the wait_valid_time dialog is
      shown if needed in auto-resume use-case.

- operation_timeout: allows to change the default timeout for plugin
  operations. The operation timeout is 10 seconds by default. The default
  operation timeout can be changed to N using <default>N<default>. Also the
  operation timeout can be specified for each operation type. To change the
  timeout for operation 'op' to N use construction: <op>N</op>. Exapmle:
    <operation_timeout>
      <default>20</default>
      <get_epg_day>30</get_epg_day>
      <handle_user_input>40</handle_user_input>
    </operation_timeout>
  As a result, all operations has timeout 20 seconds, except the
  get_epg_day() (30 seconds) and handle_user_input() (40 seconds).

High-level design overview
--------------------------

There is central Dune GUI component, that does all the job to handle remote
control, draw graphics, show video streams and so on.

The Dune GUI can also manage multiple PHP plugins.

Every PHP plugin runs in a separate process, where PHP engine is
initialized.

The Dune GUI communicates to PHP plugins using IPC (inter-process
communication), in particular: UNIX pipes. The protocol is in plain text
and uses JSON to represent structured data.

The communication is actually one-way: Dune GUI makes a request (or a
call) and asynchronously waits for a PHP plugin to reply. If the PHP plugin
failed to reply within pre-defined timeout, an error is reported.

PHP plugins are not able to initiate a call to Dune GUI.

Basically, a call from the Dune GUI to a PHP plugin can be formulated
by the following meta-declaration:

    string call_plugin(in string call_ctx_json);

  - The Dune GUI prepares a structure of some sort, where it specifies
    operation code and operation parameters (so called "input-data");

  - This structure is then encoded (serialized) to a string using JSON;

  - The string is passed to the PHP plugin using IPC;

  - PHP plugin deserializes the string to a structure, retrieves operation
    code and operations parameters, executes the operation to get another
    structure (so called "output-data") to be passed back to the Dune GUI;

  - The output structure is again serialized to a string using JSON, and
    is passed back to the Dune GUI;

  - The Dune GUI deserializes the string into a structure and uses the data
    to do needed actions.

Thus, ultimately, the PHP plugin need to implement the only one function:

    string call_plugin(in string call_ctx_json);
    (actual name see below in the "System PHP files" section)

However, it's too cumbersome and error-prone to implement the same logic
for every plugin over and over again, so SDK provides a framework, which
does all the job of marshalling data and invoking the right operation.

System PHP files
----------------

STB includes several system PHP files which are automatically sourced by
the PHP engine instance before plugin PHP program loading. PHP definitions
and symbols provided by these system PHP files are automatically available
to plugin PHP program.

In the STB firmware, these PHP files are located in "/firmware_ext/php"
directory.

These files basically defines an interface between Dune GUI and plugin PHP
programs.

The files are:

    - bootstrap.php

      - Setups error reporting within PHP engine so that all errors are
        logged to the internal log file.

      - Setups correct (current) timezone.

      - Provides the following global functions:

        - hd_print($text_message)

          This function should be used instead of PHP functions 'echo',
          'print', 'printf' etc.

          By using this function developer makes sure the text gets to the
          log file in the proper format.

          This function uses global $HD_NEW_LINE contant, which is an empty
          string ('') by default.

        - hd_silence_warnings()

          This function should be used to temporarily disable warning from
          system PHP functions.

        - hd_restore_warnings()

          This function restores warning logging after
          hd_silence_warnings().

      - The following global functions are also defined in bootstrap.php,
        but usually should not be used explicitly in PHP plugins:
        - hd_error_handler()
        - hd_shutdown_handler()
        - hd_error_silencer()

    - dune_plugin.php

      - Defines high-level interface between the Dune GUI and plugin PHP
        programs -- DunePlugin interface -- a set of operations, which
        the Dune GUI can call against the PHP program.

        If default framework (see below) is in use, all calls from the Dune
        GUI to a plugin PHP program are dispatched to an instance of
        DunePlugin interface.

    - dune_plugin_fw.php

      - Provides low-level interface (in terms of strings) between the Dune
        GUI and plugin PHP programs.

      - Provides utility functions.

    - dune_api.php

      - Contains definitions of various string constants which are
        helpful for passing the data between the plugin PHP program and
        Dune GUI.

Plugin PHP program basics
-------------------------

Every plugin PHP program eventually must do the following steps:
  - Provide a class derived from DunePluginFw;
  - Implement DunePluginFw::call_plugin() in the derived class;
  - Assign an instance of the new class to DunePluginFw::$instance;

DunePlugin interface
--------------------

On the high-level, the interface between the Dune GUI and a plugin PHP
program is specified by the DunePlugin interface, declared in
dune_plugin.php file.

Currently the DunePlugin interface looks as follows:

interface DunePlugin
{
    // PluginFolderView
    public function get_folder_view(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // PluginFolderView
    public function get_next_folder_view(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // PluginTvInfo
    public function get_tv_info(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // String
    public function get_tv_stream_url(
        /* [in]     String                      */  $playback_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // PluginVodInfo
    public function get_vod_info(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // String
    public function get_vod_stream_url(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // PluginRegularFolderRange
    public function get_regular_folder_items(
        /* [in]     String                      */  $media_url,
        /* [in]     int                         */  $from_ndx,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // List<PluginTvEpgProgram>
    public function get_day_epg(
        /* [in]     String                      */  $channel_id,
        /* [in]     int                         */  $day_start_tm_sec,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // String
    public function get_tv_playback_url(
        /* [in]     String                      */  $channel_id,
        /* [in]     int                         */  $archive_tm_sec,
        /* [in]     String                      */  $protect_code,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // void
    public function change_tv_favorites(
        /* [in]     String                      */  $op_type,
        /* [in]     String                      */  $channel_id,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    // GuiAction
    public function handle_user_input(
        /* [in]     Map: Key -> Value           */  &$user_input,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);
}

The output type of plugin operation:

class PluginOutputData
{
    Boolean                 has_data;
    PluginOutputDataType    data_type;
    Object                  data;
    Map<String, String>     plugin_cookies;
    Boolean                 is_error;
    GuiAction               error_action;
}

Each plugin operation should return one of the following:
    - normal output: 'is_error' is false, 'error_action is null, 'has_data'
      is true, 'data' contains the normal output data of type specified in
      'data_type';
    - error output: 'is_error' is true, error_action may be set to some GUI
      action to be executed.

Plugin PHP program lifecycle
----------------------------

Each PHP plugin is executed in its own instance of PHP engine (running in a
its own separate process). The PHP engine instance for each PHP plugin is
created when the PHP plugin is used for the first time.

PHP plugin always handles just one call from Dune GUI at a time. Multiple
calls from Dune GUI to PHP plugin are always serialized.

Typically, subsequent calls from Dune GUI to PHP plugin are delivered to
the same PHP engine instance. Thus, global PHP variables are preserved
between subsequent calls.

However, each PHP engine instance may be destroyed/recreated at any moment
(between calls from Dune GUI to PHP plugin) when this is needed by Dune
GUI. When this happens, global PHP variables are not preserved.

So, PHP plugin must not assume that global PHP variables are preserved
between subsequent calls from Dune GUI to PHP plugin. PHP plugin is allowed
to use global PHP variables e.g. for the implementation of some caches (may
be helpful for performance reasons), but it must be prepared that these
global variables disappear between subsequent calls and implement a proper
strategy for repopulating the caches when needed.

When possible, PHP plugin should be designed as a stateless program. When
some transient global state is needed and it is critical to preserve this
state between subsequent calls to PHP plugin, this should be implemented in
a special way, e.g.:
    - The state should be encoded in parameters which are passed between
      PHP plugin and Dune GUI, so Dune GUI keeps the state.
    - The state should be stored in the directory for temporary transient
      data (RAM disk in the STB).
    - The state should be stored on the Internet server (if PHP plugin
      interacts with some Internet server).

Plugin PHP program environment
------------------------------

1. Cookies.

    - each plugin has a list of persistent string settings known as plugin
    cookies. This map(string => string) is passed by reference to each plugin
    operation. So, operations may use cookie values and can modify them.
    The cookies keep their values between operations and even survive the
    STB restart.
    NOTE: plugin cookies are not supposed to keep large amount of data

2. System properties.

    - the PHP plugin code has access to the DuneSystem::$properties array.
      Currently the following properties are provided:

      'plugin_name' - current plugin name;
      'install_dir_path' - path to directory where plugin is installed to;
      'tmp_dir_path' - path to directory under /tmp which is designed for
          storing plugin's temporary data. Dune GUI ensures that directory
          exists.
      'data_dir_path' - path to directory for storing persistent data.
          NOTE: this directory is not available on STBs without System
          Storage and Flash Memory Storage. In the latter case
          'data_dir_path' is unset.
      'plugin_www_url' - the common HTTP prefix for WWW-files included into
          plugin (for local access);
      'plugin_cgi_url' - the common HTTP prefix for CGI scripts included
          into plugin (for local access).
       In particular, the 'plugin_www_url' and 'plugin_cgi_url' contains
          strings:
          http://127.0.0.1/plugins/<plugin_name>/
          http://127.0.0.1/cgi-bin/plugins/<plugin_name>/


NOTE: After each write into persistent location, "sync" UNIX command or
system call should be performed immediately.

Plugin PHP program main features overview
-----------------------------------------

Each method in DunePlugin interface corresponds to the so-called plugin
operation. Each operation has input type (simple) and output type
(sometimes considerably complex). The output data should be returned from
DunePlugin method as PHP array. The keys for output PHP arrays are defined
in the dune_api.php.

The PHP plugin may extend the base Dune functionality in the following
ways:

  - extend Dune menu hierarchy (the Dune menus also known as 'folders').
    Some of general Dune folders (in particular, the 'TV', 'Applications'
    and 'Setup->Applications') may be extended by adding new elements which
    are called 'plugin entry points'. Each entry point is owned by one
    plugin. Typically entry points contain folder hierarchy managed by
    plugin.

  - launch plugin-TV playback. Plugin-TV playback is the special playback
    mode allowing to play TV channels, browse list of channels united into
    categories (also known as groups), browse channel EPG etc.

  - launch plugin-VOD playback. Plugin-VOD playback is the special playback
    mode allowing to play movie or a series (list of episodes united by
    single title).

The default look and behaviour of general Dune folders is extended by
plugins in the following way:
  - new folder element is added for each registered plugin and each entry
    point in plugin manifest. The icon URL and caption for each entry point
    are taken from manifest;
  - the owner plugin takes control over user input when entry point is
    focused. Currently plugin may override the standard behaviour of the
    following remote keys in general folders: ENTER, PLAY.

The technique used by plugins to affect the behaviour of Dune GUI is base
on the concept of GUI actions. For more details about GUI actions see the
"GUI actions" section.

Briefly the GUI action is the instruction for Dune GUI what to do when user
presses remote button in particular state of GUI. GUI action is typically
created in PHP code as array with the following fields:
  - handler_string_id : [string] type of action
  - data: [array] PHP array of type-specific action parameters.

There is a number of GUI action types including:
  - PLUGIN_OPEN_FOLDER. Browses into some GUI element. Opens a new folder
    (submenu) fully managed by plugin. Such folders are called 'plugin
    folders'.
  - PLUGIN_TV_PLAY. Launches the plugin-TV playback.
  - PLUGIN_VOD_PLAY. Launches the plugin-VOD playback.
Also there is one special action type called HANDLE_USER_INPUT. Execution
of HANDLE_USER_INPUT involves:
  - running some arbitrary plugin code. Specifically, the
    handle_user_input() plugin operation is executed having current Dune
    GUI state as a parameter;
  - immediate execution of another GUI action specified by plugin.
    Actually, the return value of handle_user_input() operation is
    executed as GUI action.

The plugin folder has string identifier which is non-obviously called
'media_url'. So let's assume that every plugin folder (including entry
point) has 'media_url' value unique in scope of plugin.

The plugin folders are divided into 3 general types:

1. Regular folder.

   The most common type of folder used to show the list of objects of any
   kind as table with fixed number of rows and columns. Each table cell may
   contain image and text. The visualization of regular folder can be
   adjusted using large number of settings. Also plugin may specify several
   variants of folder representation; these variants can be switched by
   pressing A_RED remote button. Let's call variant of regular folder
   representation 'folder view'.

   The regular plugin folder behaves similar to general Dune folders but
   the effect of pressing several remote keys should be explicitly
   specified by plugin; otherwise they will be ignored. These remote keys
   are: ENTER, PLAY, INFO, POPUP_MENU, B_GREEN, C_YELLOW, D_BLUE. In other
   words plugin may assign GUI actions to the listed keys.

   The regular folders can be divided into:
    - simple (preloaded): the whole content of folder is returned at once;
    - lazy loaded with known size: the number of folder elements is known
      but it is considerably big and folder content is loaded by chunks
      when user scrolls;
    - lazy loaded with unknown size: the same as before but the number of
      total elements is unknown until end is reached.

   The most regular folders are simple; however Dune plugin framework
   have support for lazy-loading of regular folders.

2. Control folder.

   The folder type designed to be used in setup. The control folder looks
   as vertical list of GUI controls and constant text strings.

   The following controls are supported:
     - button.
     - combobox
     - text field

   Plugin may assign specific GUI actions to the following events:
     - button pressed;
     - combobox value changed;
     - text field value changed.

   The HANDLE_USER_INPUT GUI action should be used to apply/save changes.

3. Movie folder.

   The special layout for representing the detailed information about
   movie. The following movie properties can be shown in such folder:
    - movie name
    - movie name in the original language
    - poster image
    - list of genres
    - country
    - year
    - director(s)
    - actors
    etc..

   The layout also includes one or two buttons:
     - mandatory button 'PLAY' in the left-bottom corner with the following
       predefined handling. When pressed the number of movie series is
       cheched:'
       - (number_of_series > 1) => folder with list of series is opened;
       - (number_of_series = 1) => VOD-playback is launched for movie.
     - optional button with custom caption and GUI action in the
       right-bottom corner. This button may be used to implement 'Add to
       favorites' and 'Remove from favorites' use-cases.

To support the folder hierarchy the plugin PHP program should implement at
least the DunePlugin::get_folder_view($media_url).

To support the multiple folder views the plugin PHP program should
implement DunePlugin::get_next_folder_view($media_url).

To support lazy-loading of regular folders the plugin PHP program should
implement DunePlugin::get_regular_folder_items($media_url) consistently
with the DunePlugin::get_folder_view($media_url).

To apply/save changes in setup settings the plugin PHP program should
implement DunePlugin::handle_user_input($params).

The TV playback has optional features:
  - EPG browsing;
  - archive playback;
  - protected channels;
  etc.

Both TV and VOD playback modes have optional feature:
  - variable stream URLs.

To support minimal TV playback the plugin PHP program should implement
DunePlugin::get_tv_info($media_url) and
DunePlugin::get_tv_playback_url($media_url, $archive_tm_sec, $protect_code).

To support EPG browsing the plugin PHP program should implement
DunePlugin::get_day_epg($channel_id, $day_start_tm_sec);

To support archive playback the DunePlugin::get_tv_playback_url(...) should
accept non-zero $archive_tm_sec argument (consistently with the returned
data from get_tv_info());

To support protected channels feature the
DunePlugin::get_tv_playback_url(...) should accept non-empty $protect_code.

To support variable TV stream URLs the plugin PHP progam should implement
DunePlugin::get_tv_stream_url($playback_url).

To support VOD playback the plugin PHP program should implement
DunePlugin::get_vod_info($media_url).

To support variable VOD stream URLs the plugin PHP progam should implement
DunePlugin::get_vod_stream_url($playback_url).

Typical PHP program notes
-------------------------

The typical plugin PHP consists of the following.

1. The manifest file dune_plugin.xml containing:

    - plugin name
    - plugin caption
    - plugin type (php) and the main PHP program file (<plugin_name>.php)
    - the list of entry points
    - the auto_resume specification

If plugin provides IPTV service then it adds entry point to the TV menu.
This entry point reacts as PLUGIN_OPEN_FOLDER to the ENTER remote key and
PLUGIN_TV_PLAY to the PLAY remote key.

If plugin provides some non-IPTV services then it adds one or more entry
points to the Applications menu.

Also typical plugin adds one entry point to the Setup->Applications menu.

The plugins providing playback of video/audio streams should usually turn
on the 'auto_resume' feature to allow the automatic resume of playback
state after STB restart.

2. Folder hierarchy.

Usually the TV entry point contains 2-level regular folder hierarchy:
  - 1st level contains list of TV channel categories. Each category item
    acts as folder when ENTER pressed. The TV playback is launched when
    PLAY is pressed;
  - 2ns level contains channels. Each channel item react as TV_PLAY to the
    both ENTER and PLAY remote keys.

The entry points providing access to VOD services may have folder hierarchy
of arbitrary depth splitting the movie database into categories. Each
category is represented as regular folder having subcategories and movies
as elements. The movie element opens the folder or Movie type. Movie
playback can be launched from inside the movie folder.

3. Playback.

Typically the TV playback is launched:
    - by pressing ENTER/PLAY remote button on the regular folder
      element representing channel;
    - by pressing PLAY on the regular folder element representing channel
      category;
    - by pressing PLAY on the TV entry point.

Typically the VOD playback is launched:
    - by pressing ENTER/PLAY remote button on the regular folder element
      representing movie or movie series;
    - by pressing ENTER/PLAY on the PLAY button in the movie folder.

Also the TV/VOD playback can be launched automatically on STB power-on in
the autoresume use-case.

4. Setup screen.

The entry point to the setup screen is located in Setup->Applications menu.
Setup screen is implemented as plugin folder of 'Control folder' type.

Typically setup screen contains 'Show in main screen' combobox with Yes/No
values.

The HANDLE_USER_INPUT GUI action and the corresponding handle_user_input()
plugin operation should be used to apply changes and save settings in the
persistent location.
Typically the plugin cookies are used to keep setup settings locally.

Plugin operations
-----------------

The short description of the plugin operations.
NOTE: see the dune_api.php for the complete list of fields for each output
data type.

1. Get_folder_view()
~~~~~~~~~~~~~~~~~~~~

    // PluginFolderView
    public function get_folder_view(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns current folder content representation data for the plugin menu
    folder identified by $media_url.

    This operation is called when Dune GUI executes PLUGIN_OPEN_FOLDER GUI
    action.

    Output data:
    class PluginFolderView
    {
        PluginFolderViewKind         view_kind;
        union (PluginFolderViewKind) data;
        Boolean                      multiple_views_supported;
        PluginArchiveDef             archive;
    }

    The 'archive' is the optional specification of the plugin archive used
    with this folder. See "Plugin archives" section for more details about
    plugin archives.

    The 'multiple_views_supported' specifies whether the multiple views are
    are available for this folder. See description of GET_NEXT_FOLDER_VIEW
    plugin operation for more details.

    The 'view_kind' can be one of the following:
      - PLUGIN_FOLDER_VIEW_REGULAR
      - PLUGIN_FOLDER_VIEW_CONTROLS
      - PLUGIN_FOLDER_VIEW_MOVIE

    The 'data' is specific for view_kind:
      - regular folders: PluginRegularFolderView
      - control folders: PluginControlsFolderView
      - movie folders: PluginMovieFolderView

    Regular folder data
    ~~~~~~~~~~~~~~~~~~~

    class PluginRegularFolderView
    {
        ViewParams               view_params;
        ViewItemParams           base_view_item_params;
        ViewItemParams           not_loaded_view_item_params;
        GuiActionMap             actions;
        GuiTimerDef              timer;
        Boolean                  async_icon_loading;
        PluginRegularFolderRange initial_range;
    }

    The 'initial_range' specifies the initial range of folder elements.
    The initial range for simple (preloaded) folders should contain all
    folder elements. The initial range for lazy-loaded folders should
    contain the first chunk of data or even the empty list. See the
    description of Get_regular_folder_items() plugin operation.

    The 'view_params' specifies the whole folder representation paramsters
    such as num_cols, num_rows, async_icon_loading etc..

    The 'async_icon_loading' specifies whether to use asynchronous icon
    loading by default. See "Asynchronous image loading" section for more
    details.

    The 'base_view_item_params' specifies the default values for
    representation parameters of each folder element.

    The 'not_loaded_view_item_params' specifies the representation of the
    special state of each folder element. It is used when element's image
    is (1) not yet loaded or (2) loaded with error (loading failed).
    NOTE: currently this value is ignored if
    ViewParams::async_icon_loading == false.

    The 'actions' specifies the {event -> GUI action} mapping for interaction
    with user.

    The 'timer' allows to specify timer event delay. The timer event will
    be generated only once, but timer can be reset using ChangeBehaviour
    GUI action.

    Control folder data
    ~~~~~~~~~~~~~~~~~~~

    class PluginControlsFolderView
    {
        Array<GuiControlDef>    defs;
        int                     initial_sel_ndx;
        PluginFolderViewParams  params;
    }

    class PluginFolderViewParams
    {
        Boolean     paint_path_box;
        Boolean     paint_content_box_background;
        String      background_url;
    }

    The 'defs' specifies list of GUI control definitions. See the
    "GUI controls" section for more details.

    The 'initial_sel_ndx' specifies the 0-based index of GUI control to
    gain focus first. The special value of -1 value indicates that default
    (first) GUI control should be focused first.

    Movie folder data
    ~~~~~~~~~~~~~~~~~

    class PluginMovieFolderView
    {
        PluginMovie             movie;

        String                  left_button_caption;
        GuiAction               left_button_action;

        Boolean                 has_right_button; String
        String                  right_button_caption;
        GuiAction               right_button_action;

        Boolean                 has_multiple_series;
        Boolean                 series_media_url;

        PluginFolderViewParams  params;
    }

    class PluginFolderViewParams
    {
        Boolean     paint_path_box;
        Boolean     paint_content_box_background;
        String      background_url;
    }

    The 'movie' specifies a number of movie properties. See the list of
    movie properties below.

    The 'left_button_caption' specifies caption of the left button. This
    property is optional, the 'Play' is used by default.

    The 'left_button_action' specifies GUI action assigned with left
    button. This value is optional, the VOD_PLAY gui action is used by
    default.

    The 'has_right_button' specifies whether button in the right-bottom
    corner of movie folder page should be painted.

    The 'right_button_caption' specifies caption of the right button.

    The 'right_button_action' specifies GUI action assigned with right
    button.

    The 'has_multiple_series' specifies the effect of pressing ENTER remote
    key on the PLAY GUI button located in the left-bottom corner of movie
    folder page:
        - when FALSE => PLUGIN_VOD_PLAY GUI action is executed
        - when TRUE => PLUGIN_OPEN_FOLDER GUI action is executed with
          explicit media_url taken from 'series_media_url' parameter.
    This scheme is designed to implement use-case of series, i.e. movie
    divided into series. In this case pressing ENTER remote key should have
    effect of opening the list of series.

    The 'series_media_url' is used with 'has_multiple_series' = true. It
    identifies the folder which should be opened when user press ENTER
    remote button having PLAY button focused.

    class PluginMovie
    {
        String  name;
        String  name_original;
        String  description;
        String  poster_url;
        int     length_min;
        int     year;
        String  directors_str;
        String  scenarios_str;
        String  actors_str;
        String  genres_str;
        String  rate_imdb;
        String  rate_kinopoisk;
        String  rate_mpaa;
        String  country;
        String  budget;
        Map<String,String> details;
        Map<String,String> rate_details;
    }

    - The 'details': additional pars in the main (scrollable) area.

    - The 'rate_details': additional lines in the ratings area (under
      poster).

2. Get_next_folder_view()
~~~~~~~~~~~~~~~~~~~~~~~~~

    // PluginFolderView
    public function get_next_folder_view(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns next folder view for the plugin menu folder identified by
    $media_url.

    Some regular folders may have several views (e.g. with different
    num_rows, num_cols, different size of icons etc..). Such views can be
    switched by pressing A_RED remote button. To enable this feature for
    particular folder, plugin should specify
    PluginFolderView::multiple_views_supported == true. In this case
    pressing A_RED will cause Get_next_folder_view() to be called.

    See Get_folder_view() plugin operation description for more details.

3. Get_regular_folder_items()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // PluginRegularFolderRange
    public function get_regular_folder_items(
        /* [in]     String                      */  $media_url,
        /* [in]     int                         */  $from_ndx,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns the specified chunk of folder element for the folder identified
    by $media_url.

    This is part of lazy-loading feature of regular folders.

    Dune GUI never calls this operation for simple (preloaded) folder.

    The Get_regular_folder_items() operation is called for lazy-loaded
    folder each time some not yet loaded elements should be visualized
    (typically when user scrolls though the folder elements). The folders
    element are cached in memory until folder is exitted.

    See Get_folder_view() operation description for more details.

4. Get_tv_info()
~~~~~~~~~~~~~~~~

    // PluginTvInfo
    public function get_tv_info(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns data needed to launch plugin TV playback. The $media_url
    argument is used as hint about what channel should be played first.

    This operation is called when Dune GUI executes PLUGIN_TV_PLAY GUI
    action.

    The output data of get_tv_info:

    class PluginTvInfo
    {
        unixtime_t              server_time;
        List<PluginTvGroup>     groups;
        List<PluginTvChannel>   channels;
        Boolean                 show_group_channels_only;
        Boolean                 favorites_supported;
        List<String>            favorite_channel_ids;
        String                  favorites_icon_url;
        String                  initial_group_id;
        String                  initial_channel_id;
        Boolean                 initial_favorites;
        unixtime_t              initial_archive_tm;
        Boolean                 ip_address_required;
        Boolean                 valid_time_required;
        EpgMode                 epg_mode;
        PluginFontSize          epg_font_size;
        PluginArchiveDef        archive;
    }

    The 'server_time' specify the current time to be used during TV
    playback. The local time is used if server time is non-positive.

    The 'groups' and 'channels' specify the list of channels and the list
    of channel groups. See the description of group and channel properties
    below.

    The 'show_group_channels_only' specifies the way channels are grouped.

    The plugin TV browser OSD consists of 3 columns:
      - 1st column contains list of groups;
      - 2nd column contains list of channels for the selected group;
      - 3rd column contains list of EPG programs for the selected
        channel and the choosen day.

        - if ['show_group_channels_only' == false] the 2nd column contains
          all channels sorted by groups not depending on what group is
          selected. This mode requires the 1-to-N relationship between
          groups and channels, i.e. each channel should belong to exactly
          one group. The group selection in 1st column is adjusted
          automatically when user scrolls channel list in 2nd column.

        - if ['show_group_channels_only' == true] the 2nd column contains
          channels of the selected group only. This mode suports N-to-N
          relationship between groups and channals: channal can be included
          into multiple groups. As a consequence user has to move focus
          between 2nd and 1st columns by pressing LEFT/RIGHT to select
          channel from another group.

    When 'favorites_supported' enables *favorites* feature including:
        - special "favorites" group added to the list of groups;
        - special key handling for modification of the list of favorite
          channels. In particular Dune GUI calls Change_tv_favorites()
          operation when user press D_BLUE, B_GREEN, C_YELLOW remote keys.
          The implementation of Change_tv_favorites() should write the
          list of favorite channels to the persistent storage (e.g. by
          means of cookies).

    The 'favorite_channel_ids' specify the list of favorite channels.

    The 'favorites_icon_url' specify the icon for "favorites" group.

    The 'initial_group_id', 'initial_channel_id', 'initial_favorites' and
    'initial_archive_tm' specify the initial state of playback and selection.
    All these properties are optional; if property is unset then it is
    automatically set to the appropriate value.
    If positive value given, the 'initial_archive_tm' specify that archive
    playback should be started from the given timestamp (GMT unixtime).

    The 'ip_address_required' and 'valid_time_required' specify the
    additional requirements for the TV playback. See the desciption of the
    similar fields in plugin manifest for more details. In particular, it
    is common that some plugins do not require valid current time for
    browsing groups/channels in Dune menu but they do requre valid time for
    TV playback.

    The 'epg_mode' it can take 3 values:
        - "disabled": the get_day_epg() calls are avoided, but EPG-column
          is still shown with "No program available." text. This mode
          should be used if no EPG is available at all. The concrete
          behaviour may be changed in future.
        - "use_day_request": the default mode.
        - "get_from_stream": not implemented yet.

    Each group has the following properties:

    class PluginTvGroup
    {
        String id;
        String caption;
        String icon_url;
    }

    The 'id' specifies group identifier.

    The 'caption' and 'icon_url' specify group representation.

    Each channel has the following properties:

    class PluginTvChannel
    {
        String          id;
        String          caption;
        List<String>    group_ids;
        String          icon_url;
        int             number;
        Boolean         have_archive;
        Boolean         is_protected;
        Boolean         recording_enabled;
        int             buffering_ms;
        int             timeshift_hours;
        int             past_epg_days;
        int             future_epg_days;
        int             archive_past_sec;
        int             archive_delay_sec;
        Boolean         playback_url_is_stream_url;
    }

    The 'id' specifies channel identifier.

    The 'caption' and 'icon_url' specify channel representation.

    The 'group_ids' specifies groups this channel belongs to. There should be
    at least one group specified. Some plugins allow channel to belong to
    multiple groups, the others are not. See the description of
    PluginTvInfo::show_group_channels_only for more details.

    The 'number' allows to assign the concrete number to TV channel. If
    number <= 0 => the number will be assigned automaticaly to the first
    unused positive integer.

    The 'have_archive' enables archive feature for this channel. If
    enabled, the corresponding support in the implementation of
    Get_tv_playback_url() operation whould be provided. See "Plugin TV
    archive playback" section for more details about TV archive playback.

    The 'is_protected' marks this channel as protected, i.e. restricted for
    users who do not know the key. If plugin have some protected channels,
    the corresponding support in the Get_tv_playback_url() should be
    provided.

    The 'recording_enabled' specifies whether recording is enabled for this
    channel.

    The 'buffering_ms' specify the prebuffering time for channel playback.

    The 'timeshift_hours' specify the timeshift in hours. NOTE: not
    implemented yet.

    The 'past_epg_days' and 'future_epg_days' specify the limits of
    scrolling the EPG. The default values are 14.

    The 'archive_past_sec' specifies the maximum time interval from current
    moment and the last moment in the past the archive is available for.
    See "Plugin TV archive playback" section feature for more details about
    TV archive playback.

    The 'archive_delay_sec' specifies the time interval in seconds between
    the current moment and the nearest moment in past the archive is
    available for. See "Plugin TV archive playback" section feature for
    more details about TV archive playback.

    The 'playback_url_is_stream_url' specifies whether the playback URL is
    stream URL for this channel.

5. Get_day_epg()
~~~~~~~~~~~~~~~~

    // List<PluginTvEpgProgram>
    public function get_day_epg(
        /* [in]     String                      */  $channel_id,
        /* [in]     int                         */  $day_start_tm_sec,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns list of EPG program structures for the given channel and given
    day.

    The day is specified by the unixtime of it's beginning (0:00). I.e. the
    $day_start_tm_sec is always divisible by 86400.

    The output should be a (possibly empty) list of structures sorted by
    time in ascending order:

    class PluginTvEpgProgram
    {
        unixtime_t start_tm_sec;
        unixtime_t end_tm_sec;
        String     name;
        String     description;
    }

    The 'start_tm_sec' and 'end_tm_sec' are the program start/end time in
    unixtime format.
    The 'end_tm_sec' is optional (the -1 value means unset).
    The 'name' is required non-empty program name.
    The 'description' is optional program description.

6. Change_tv_favorites()
~~~~~~~~~~~~~~~~~~~~~~~~

    // GuiAction
    public function change_tv_favorites(
        /* [in]     String                      */  $op_type,
        /* [in]     String                      */  $channel_id,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Updates the list of favorite TV channels.

    Is called from TV playback mode when user press B_GREEN, C_YELLOW,
    D_BLUE remote buttons.

    The return value is the optional GUI action to be executed immediately.

    The following update operations supported:
      - PLUGIN_FAVORITES_OP_ADD
      - PLUGIN_FAVORITES_OP_REMOVE
      - PLUGIN_FAVORITES_OP_MOVE_UP
      - PLUGIN_FAVORITES_OP_MOVE_DOWN

    The implementation of change_tv_favorites() should update it's own
    persistent copy of favorites. There list of favorites inside Dune GUI
    will be updated automatically.

7. Get_tv_playback_url()
~~~~~~~~~~~~~~~~~~~~~~~~

    // String
    public function get_tv_playback_url(
        /* [in]     String                      */  $channel_id,
        /* [in]     int                         */  $archive_tm_sec,
        /* [in]     String                      */  $protect_code,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns the playback URL for the given channel as string.

    This operation is called for getting playback URL of:
        - live playback if $archive_tm_sec <= 0;
        - archive playback if $archive_tm_sec > 0.
    See "Plugin TV archive playback" section for more details about TV
    archive playback.

    The nonempty protect_code can be specified for protected channels. See
    "Protected TV channels" section for more details about protected TV
    channels.

    This operation is called each time the playback of particular channel
    is started or resumed.

    NOTE: some channels require to perform additional call to
    Get_tv_stream_url() for getting the actual stream URL having playback
    URL as the parameter. This use-case is indicated by
    PluginTvChannel::playback_url_is_stream_url == false.

8. Get_tv_stream_url()
~~~~~~~~~~~~~~~~~~~~~~

    // String
    public function get_tv_stream_url(
        /* [in]     String                      */  $playback_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns the TV stream url having the TV playback url as input.

    Examples of possible TV stream urls:
        - Multicast TS-over-UDP stream (raw-UDP or RTP-over-UDP):
            - udp:/@ip-address:port
        - Unicast TS-over-HTTP stream:
            - http://ts://host[:port][/path]

    The reason for separation of terms 'playback URL' and 'stream URL' is
    the following. Sometimes plugin is unable to provide fixed URL for IPTV
    stream playback and can only provide a way of receiving this URL by
    means of remote call. And each call will return different result. To
    implement such plugins one should do the followig:
      - for each such channel the
        PluginTvChannel::playback_url_is_stream_url should be set to false
      - the Get_tv_playback_url() should return string which:
          1. will be used for default playback engine initialization. So it
             must have correct prefix (e.g. http://ts://);
          2. will be passed to the Get_tv_stream_url() operation as
             parameter.
      - the Get_tv_stream_url() should be implemented to decode the
        playback URL, perform the remote call, parse the results and return
        the actual IPTV stream URL.

    So lets call 'playback URL' such intermediate URL which is used for
    playback engine pre-initiallization and for being passed to
    Get_tv_stream_url() operation.
    Lets call 'stream URL' the result of Get_tv_stream_url() operation
    which is used for actual playback.

    NOTE: if PluginTvChannel::playback_url_is_stream_url is set to TRUE
    then playback URL is interpreted as stream URL and Get_tv_stream_url()
    is never called.

9. Get_vod_info()
~~~~~~~~~~~~~~~~~

    // PluginVodInfo
    public function get_vod_info(
        /* [in]     String                      */  $media_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns data for launching plugin VOD playback using the given optional
    $media_url as the hint about what series to start from.

    This operation is typically called when user presses PLAY or ENTER
    remote button on some plugin folder item having the 'plugin_vod_play'
    action registered for the corresponding key event.

    This operation launches the playback of the list of movie series.
    Number of series >= 1.

    The output data of get_vod_info:

    class PluginVodInfo
    {
        String                      name;
        String                      description;
        String                      poster_url;
        List<PluginVodSeriesInfo>   series;
        int                         initial_series_ndx;
        int                         initial_position_ms;
        int                         buffering_ms;
        Boolean                     advert_mode;
        GuiActionMap                actions;
        GuiTimerDef                 timer;
        Boolean                     ip_address_required;
        Boolean                     valid_time_required;
    }

    class PluginVodSeriesInfo
    {
        String  name;
        String  playback_url;
        Boolean playback_url_is_stream_url;
    }

    The 'name', 'description', 'poster_url' and 'series[i]->name' are used
    for OSD representation.

    The 'series' specifies the list of series to play. They form a some
    sort of playlist.

    The 'initial_series_ndx' specifies the index of series to start
    playback from.

    The 'initial_position_ms' specifies the initial playback position in
    milliseconds. If negative value specified then the default initial
    position will be chosen (resume is possible).

    The 'advert_mode': if TRUE, the VOD playback will be started with the
    following limitations:
        - some features disabled: seek, jump, change playback speed and
          similar;
        - very limited OSD is shown (e.g. the info block and status never
          shown). However, some features are enabled: image setup, zoom,
          audio/subtitles setup etc.

    The 'ip_address_required' and 'valid_time_required' specify correct
    behaviour in the case of unavailable IP address and/or valid time. See
    the description of GET_TV_INFO operation output data for more details.

    The 'buffering_ms' specify the prebuffering time in milliseconds. NOTE:
    not implemented now.

    The 'actions' allows to specify actions to be executed in the following
    use-cases during VOD playback:
      - particular key is pressed. Currently only color-keys are supported
        (A_RED, B_GREEN, C_YELLOW and D_BLUE); The events of the following
        kinds can be used: GUI_EVENT_KEY_A_RED, GUI_EVENT_KEY_B_GREEN,
        GUI_EVENT_KEY_C_YELLOW, GUI_EVENT_KEY_D_BLUE.
      - timer event occured. The event of kind GUI_EVENT_TIMER should be
        used for the case.
      - playback stopped, or playback of another media_url started, or
        power off requested. The event of kind GUI_EVENT_PLAYBACK_STOP
        should be used for the case. If action is specified for playback
        stop, the actual playback stop/switch/shutdown will be delayed
        until action execution is finished. However, the additional
        STOP/POWER-OFF key press will cancel the action execution.

    The 'timer' allows to specify timer event delay. The timer event will
    be generated only once, but timer can be reset using ChangeBehaviour
    GUI action.

    The 'series->playback_url' specify the playback URL for specific
    series.

    The 'series->playback_url_is_stream_url':
      - true => playback URL should be used as stream URL;
      - false => Get_vod_stream_url() operation should be called to get
        stream URL each time it is needed.
    See the descripton of GET_TV_STREAM_URL and GET_VOD_STREAM_URL for more
    details.

10. Get_vod_stream_url()
~~~~~~~~~~~~~~~~~~~~~~~~

    // String
    public function get_vod_stream_url(
        /* [in]     String                      */  $playback_url,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    Returns the VOD stream url having the VOD playback url as input.

    Examples of possible VOD stream urls:
        - MP4 container over HTTP (the most recommended one):
            - http://mp4://host[:port][/path]
        - TS container over HTTP:
            - http://ts://host[:port][/path]
        - Other container over HTTP (support/performance is limited):
            - http://host[:port][/path]
        - MMS (support is limited)
            - mms://host[/path]

    This operation is called each time the playback should be
    stared or resumed and the
    PluginVodInfo::series[ndx]->playback_url_is_stream_url is false. The
    PluginVodInfo::series[ndx]->playback_url is passed as a parameter.

    See description of Get_tv_stream_url() operation for more details.

11. Handle_user_input()
~~~~~~~~~~~~~~~~~~~~~~~

    // GuiAction
    public function handle_user_input(
        /* [in]     Map: Key -> Value           */  &$user_input,
        /* [inout]  Map: Key -> Value           */  &$plugin_cookies);

    This operation is called during execution of HANDLE_USER_INPUT GUI
    action.

    Handle_user_input() operation may return another GuiAction object which
    will be executed immediately.

    This operation allows to implement many complex use-cases. Here are
    some of them:
      - regular folders with elements of different types: the
        HANDLE_USER_INPUT GUI action is mapped to some keys in definition
        of such folders.
      - setup screens with possibility to edit list of settings; the
        HANDLE_USER_INPUT is specified as confirm/apply action to
        text_fields/comboboxes or assigned to some "Apply" button.
      - implementing 'Control dialogs': flexible dialogs with custom list
        of controls. The behaviour of control dialogs is very close to the
        behaviour of control folders.

GUI actions
-----------

GUI action concept is an important part of plugin PHP API. It is used by
plugins to specify the behaviour of Dune GUI in many use-cases.

In particular, GUI action is often assigned to the event of pressing remote
key by user. Also GUI action can be produced as a result of execution of
another GUI action. Also GUI action can be returned by every operation
instead of normal output in case of error.

Each GUI action implies some algorithm to be performed by Dune GUI.

The GUI action is received from plugin in form of GuiAction:

class GuiAction
{
    String              handler_string_id;
    Any                 data;
    Map<String, String> params;
}

The 'handler_string_id' specifies string identifier of the action type.
Each action type will be described below.

The 'data' specifies parameters of action. The 'data' is object of class,
specific for the action type. The data classes for all supported action
types will be described below.

The 'params' specify additional action parameters of String type. These
parameters are automatically filled with some kind of 'execution context'
in particular use-cases desribed below.

The GUI action is created to be executed by Dune GUI when some event occur.
Here is the details of action execution:

1. First the Dune GUI chooses the executor according to the current GUI state.
Now there are 3 types of executors:
    - Main executor. It is used during browsing of the Dune menu (browsing
      of the folder hierarchy), including the popup menus and dialogs. This
      executor can handle all types of actions.
    - Playback executor. This executor is used during plugin TV/VOD
      playback. Currently it may perform only the following action types:
        - PluginHandleUserInput
        - PluginShowError
        - ChangeBehaviour
        - PluginInvalidateFolders
        - PluginVodPlay (currently with some limitations: vod_info
              parameter is mandatory).
    - Light executor. It is used when handling the error-actions produced
      by plugin operations during plugin TV/VOD playback. Currently this
      executor may perform only PluginShowError action.

2. Executor analyzes type of the action. If type is not known for executor
then execution is finished with status 'Action not recognized'. The actual
not recognized action is also provided.

3. Executor performs actual execution of the given action. As a result of
   this step the following data is produced:
    - [int] execution status (Ok = 0, Error = -1, etc..)
    - [GuiAction] post action. Optional.
   If post action is not null then it should be executed immediately; so we
   replace the old action with new one and go to the step (2).
   Otherwise execution is finished with execution status returned from the
   last executed action.

List of GUI action types
------------------------

The full list of GUI action types and their explicit properties is provided
below:

1. PluginOpenFolderAction
    Data:
        class PluginOpenFolderActionData
        {
            String caption; // optional; default = null (auto)
            String media_url; // optional; default = null (auto)
        }

    Action:
        browses into plugin folder. In more details:
            - folder caption is added to path block;
            - the Get_folder_view($media_url) plugin operation executed;
            - the output data is used to show contents of folder.
    Params:
        'media_url':
            - if not null it is used as identifier of folder to be opened;
              otherwise media_url of the currently selected folder element
              is used. If no element is selected => action is ignored.
        'caption':
            - is used as path element if not null; otherwise caption of
              currently selected folder element is used.
    Returns:
        post action: never
        status: ok/failed

2. PluginTvPlayAction
    Data:
        class PluginTvPlayActionData
        {
            String initial_group_id; // optional, default = null (auto)
            String initial_channel_id; // optional, default = null (auto)
            Boolean initial_is_favorite; // optional, default = false;
            unixtime_t initial_archive_tm; // optional, default = -1 (unset)
        }

    Action:
        launches TV playback. The selection and playback state is
        initialized using the given parameters. In more details:
            - media_url of currently selected folder element is taken; if
              none is selected then $media_url is null;
            - Get_tv_info($media_url) plugin operation is executed;
            - if output is invalid => action is failed;
            - TV playback state is initialized using received PluginTvInfo;
            - if some of initial_XXX parameters are set => they override
              the default selection and playback state.
    Returns:
        post action: never
        status: ok/failed

3. PluginVodPlayAction
    Data:
        class PluginVodPlayActionData
        {
            PluginVodInfo vod_info; // optional, default = null.
        }

    Action:
        launches VOD playback. If 'vod_info' is specified, it is used to
        initialize VOD playback. Otherwise, the
        get_vod_info($current_media_url) will be called and the result vod
        info will be used. The $current_media_url is the media_url of
        currently selected folder element; if none is selected then
        $media_url is null.

    Returns:
        post action: never
        status: ok/failed

4. PluginHandleUserInputAction
    Data:
        [none]

    Action:
        runs Handle_user_input(GuiAction::$params) plugin operation.
        The output data from Handle_user_input() is returned as
        post action.

    Returns:
        post action: the action returned from Handle_user_input()
        operation
        status: ok/failed

5. PluginShowErrorAction
    Data:
        class PluginShowErrorActionData
        {
            Boolean fatal;
            String title;
            List<String> msg_lines; [optional]
        }

    Action:
        - shows error to the user. In playback state the single text line
          is shown in the center of the screen; in Dune menu state the
          dialog is shown with given title and message lines;
        - if (fatal == true) => the exit from plugin by fatal error is
          scheduled. In this case playback is stopped and Dune browser is
          moved to the top menu;
        - returns error status.

    Returns:
        post action: never
        status: failed

6. ShowDialogAction
    Data:
         class ShowDialogActionData
         {
             String title;
             List<GuiControlDef> defs;
             GuiActionMap actions; // optional
             GuiTimerDef timer; // optional
             Boolean close_by_return; // optional, default = false
             int preferred_width; // optional, default = 0 (auto)
             int max_height; // optional, default = 0 (auto)
             int initial_sel_ndx; // optional, default = -1 (auto)
         }

         class GuiTimerDef
         {
             // Timer delay in milliseconds. Zero value is allowed here.
             int delay_ms;
         }

     Action:
         shows the specified control dialog and interacts with user until
         dialog is closed.
         The 'actions' allows to specify actions to be executed when
         particular key is pressed or timer event occured. The
         GUI_EVENT_KEY_ENTER behaviour cannot be changed.
         The 'timer' allows to specify the timer event. The timer event
         will be generated only once, but the timer can be reset
         using ChangeBehaviour GUI action.
     Returns:
         post action: if dialog is closed by means of CloseDialogAndRun GUI
             action => the CloseDialogAndRunActionData::post_action is
             returned as post action
         status: ok

 7. CloseDialogAndRunAction
     Data:
         class CloseDialogAndRunActionData
         {
             GuiAction post_action; // optional, default = null (none)
         }

     Action:
         Closes current control dialog and returns 'post_action' as a result
         of caller SHOW_DIALOG GUI action.
         This action is ignored when executed outside of control dialog.
     Returns:
         post action: none
         status: ok

 8. ResetControlsAction
     Data:
         class ResetControlsActionData
         {
             List<GuiControlDef> defs;
             int initial_sel_ndx; // optional, default = -1 (do not change selection)
             GuiAction post_action; // optional, default = null (none)
         }

     Action:
         replaces state of current control dialog or control folder.

         This action is ignored when executed outside of control dialog or
         folder.
     Returns:
         post action: from action data
         status: ok

 9. ShowPopupMenuAction
     Data:
         class ShowPopupMenuActionData
         {
             List<GuiMenuItemDef> menu_items;
             int selected_menu_item_index; // optional, default = 0
         }

     Action:
         shows the specified popup menu and interacts with user until popup
         menu is closed. If user chooses popup menu item then the
         corresponding action is returned as post action.
     Returns:
         post action: the action assigned to menu item chosen by user
         status: ok

 10. StatusAction
     Data:
         class StatusActionData
         {
             int status;
         }

     Action:
         just returns the given status.
     Returns:
         post action: none
         status: ok

 11. PluginUpdateFolderAction
     Data:
         class PluginUpdateFolderAction
         {
             PluginRegularFolderRange range;
             Boolean need_refresh;
             int sel_ndx; // optional, default = -1 (do not change current)
         }

     Action:
         Partially replaces state of current plugin regular folder:
             - if need_refresh is TRUE => cached folder state is cleared;
             - the given range is applied/replaced;
             - if sel_ndx >= 0 then focus is moved to element with given
               index.
         This action is ignored when executed outside of regular folder.
     Returns:
         post action: none
         status: ok

 12. PluginInvalidateFolders
     Data:
         class PluginInvalidateFoldersActionData
         {
             List<String> media_urls;
             GuiAction post_action; // optional, default = null (none)
         }

     Action:
         clears the cached data about plugin folders identified by given
         media_urls forcing them to be fully reloaded.
         This action is needed for the case when some actions inside child
         folder changed state of parent folder. Using this action one is
         able to force parent folder to reload it's state.
         If mentioned media_url is not cached => it is ignored.

     Returns:
         post action: from action data
         status: ok

 13. PluginRunNativeCode GUI action.
     Data:
         [none]

     Action:
         loads native library 'native_code.so' from plugin installation
         directory and tries to invoke some function from this library.

     Returns:
         post action: none
         status: ok/failed

 14. PluginClearArchiveCache GUI action.
     Data:
         class PluginClearArchiveCacheActionData
         {
             String archive_id; // optional, default = null (all)
             GuiAction post_action; // optional, default = null (none)
         }

     Action:
         deletes the cached data of the plugin archives from file system (if
         exist). If 'archive_id' is set => only the specified archive is
         cleared; otherwise all archives of the current plugin are cleared.
     Returns:
         post action: from action data
         status: ok

 15. DvdPlay
     Data:
         class DvdPlayActionData
         {
             String url;
         }

     Action:
         launches DVD playback of the given url.
     Returns:
         post action: never
         status: ok/failed

 16. BlurayPlay
     Data:
         class BlurayPlayActionData
         {
             String url;
         }

     Action:
         launches Blu-Ray playback of the given url. This action is
         available in firmware supports blu-ray playback.
     Returns:
         post action: never
         status: ok/failed

 17. FilePlay
     Data:
         class FilePlayActionData
         {
             String url;
         }

    Action:
        launches normal playback on the single file pointed by given URL.
        URL should point to audio or video file or stream of supported
        format.
    Returns:
        post action: never
        status: ok/failed

18. PlaylistPlay
    Data:
        class PlaylistPlayActionData
        {
            String url;
            int start_index;
        }

    Action:
        launches normal file playback on the playlist built from the file
        or folder pointed by the given URL. URL may point to:
        - single local/network/http audio/video file or other supported
          network resource;
        - local/network/http playlist file (m3u, pls);
        - local/network folder containing audio/video/playlist files.
        The first played playlist item will be selected using the given
        "start_index", if valid.
    Returns:
        post action: never
        status: ok/failed

19. LaunchMediaUrl
    Data:
        class LaunchMediaUrlActionData
        {
            String url;
            GuiAction post_action;
        }

    Action:
        1. build playlist recursively using the given URL as root element
           of hierarchy;
        2. analyze the content of playlist and choose the actual executor;
        3. run the chosen executor against the playlist.

        The recursive algorithm does the following:
            - enters recursively into local/network folders, local/network/http
              playlists (m3u, pls);
            - adds to the playlist audio/video/image files and streams,
              DVD/Bluray files and folders, Flash-applications (swf://* and
              local *.swf), WWW-urls (www://*, *.url, *.URL)
        Possible playlist executors are:
            - DVD player; it is chosen if playlist contains only one
              element which is either DVD folder or DVD disk image file;
            - Blu-ray player; it is chosen if playlist contains only one
              element which is either Blu-ray folder or Blu-ray disk image file;
            - Flash player; it is chosen if playlist contains only one
              element: either *.swf file or swf://* url;
            - Web browser; it is chosen if playlist contains only one
              element: either *.url/*.URL file or www://* URL;
            - Photo viewer: it is chosen if playlist contains only image
              files of known types (jpg, png, bmp, gif);
            - Plugin installer: it is chosen if playlist contains only one
              element: plugin_installer://* URL.
            - Plugin uninstaller: it is chosen if playlist contains only one
              element: plugin_uninstaller://* URL.
            - Plugin launcher: it is chosen if playlist contains only one
              element: plugin_launcher://* URL.
            - general file playback: otherwise.

    Returns:
        post action: from action data.
            NOTE: post-playback action execution now is not fully
            implemented; currently post action will be taken into account
            only if actual playlist executor is one of the following:
                - plugin installer;
                - plugin uninstaller;
                - plugin launcher;
                - general file playback (some restrictions are possible).
            In future, support for action post-execution will be added for
            more playlist executors.
        status: ok/failed

20. ShowMainScreen
    Data:
        class ShowMainScreenActionData
        {
            GuiAction post_action;
        }

    Action:
        switches to the main screen.
        This action is added to improve some auto_start use-cases.
        NOTE: current implementation has limitations.
    Returns:
        post action: from action data
        status: ok/failed

21. ShowBlackScreen
    Data:
        class ShowBlackScreenActionData
        {
            GuiAction post_action;
        }

    Action:
        switches to the black screen.
        This action is added to improve some auto_start use-cases.
        NOTE: current implementation has limitations.
    Returns:
        post action: from action data
        status: ok/failed

22. ChangeBehaviour
    Data:
        class ChangeBehaviourActionData
        {
            GuiActionMap actions; // Optional.
            GuiTimerDef timer; // Optional.
            GuiAction post_action; // Optional.
        }

        class GuiTimerDef
        {
            // Timer delay in milliseconds.
            int delay_ms;
        }

    Action:
        changes the behaviour in the current GUI container. Currently the
        following GUI containers supported:
            - regular folder;
            - control dialog;
            - VOD playback.
        In future, other containers will be supported too (control/movie
        folder, TV playback, general playback).
        If 'actions' is set, it replaces the existing one.
        If 'timer_ms' is set, the timer is restarted from the current time
        moment.
    Returns:
        post action: from action data
        status: ok/failed

GUI controls
------------

GUI controls may appear in the following GUI control containers:
    - plugin control folders;
    - control dialogs.

The look and behaviuor of control folders and control dialogs is very
similar. GUI controls are positioned from top to the bottom, have 1 or
2 columns and each column is left-aligned. Each control may have optional
'title' text string. When title is specified, it is located in 1st column
and control itself is located in 2nd column. When title is not specified,
GUI control is located in 1st column and nothing is placed into 2nd column.
The width of GUI controls in 2nd column can be automatically arranged (if
GUI control does not specify width explicitly).

Control folder is opened by means of PLUGIN_OPEN_FOLDER GUI action. The
subsequent call to Get_folder_view() operation returns, among the other
data, the control folder specification:

    class PluginControlsFolderView
    {
        Array<GuiControlDef>    defs;
        int                     initial_sel_ndx;
    }

The plugin control folders can be closed in the same way as other Dune
folders: by means of RETURN, TOP_MENU.

Control dialog is opened by means of SHOW_DIALOG GUI action:

    class ShowDialogActionData
    {
        String title;
        List<GuiControlDef> defs;
        Boolean close_by_return; // optional, default = false
        int preferred_width; // optional, default = 0 (auto)
    }

If 'close_by_return' is true => dialog can be closed by RETURN; otherwise
it cannot.
The only other way to close dialog is to provoke execution of
CLOSE_DIALOG_AND_RUN GUI action. Normally actions of this type are assigned
to at least one button in control dialog.

The core of control folder and dialog's specification is the list of GUI
control definitions of type:

    class GuiControlDef
    {
        String name;
        String title;
        GuiControlKind kind;
        Object specific_def;
    }

The 'name' specify identifier of GUI control. It is used for passing the
current value of GUI control to the GUI actions invoked inside the
container.

The 'title' specify optional string title.

The 'kind' specify kind of GUI action:

    enum GuiControlKind
    {
        GUI_CONTROL_LABEL,
        GUI_CONTROL_COMBOBOX,
        GUI_CONTROL_TEXT_FIELD,
        GUI_CONTROL_BUTTON,
        GUI_CONTROL_VGAP
    }

The 'specific_def' contains additional parameters specific for the
particular GUI control kind.

Label
~~~~~

Data:
    class GuiLabelDef
    {
        String caption;
    }

Details:
    GUI label is painted as fixed single-line text string. If string is too
    long, it is truncated in center.

Parameters:
    'caption' - the text string.

Combobox
~~~~~~~~

Data:
    class GuiComboboxDef
    {
        String initial_value; // Optional, default = null (first)
        List<Pair<String, String>> value_caption_pairs;
        int width; // optional; default = -1 (auto)
        GuiAction confirm_action; // optional; default = null (none)
        GuiAction apply_action; // optional; default = null (none)
    }

Details:
    GUI combobox is painted as standard Dune combobox. It can reside in 3
    states:
        - unfocused: main component painted without focus;
        - focused: main component painted with focus; ENTER key is
          intercepted to swith to active state;
        - active; main component painted with focus and the drop-down menu
          component is painted; the arrow keys, ENTER and RETURN are
          intercepted.

Parameters:
    'value_caption_pairs' - the combobox model: the list of pairs
    {choice_value, choice_caption}. The choice_caption is painted on screen and
    the choice_value is used as choice identifier.

    'initial_value' - the choice_value to be selected first.

    'width' - the width of combobox; if not specified => the default width
    is used; actually combobox width cannot be less than the default value.

    'confirm_action' - if specified, it is executed when user press ENTER
    in the drop-down menu. During confirm_action's execution the choice is
    not applied and combobox remains in 'active' state. If execution status
    is OK => choice is applied (combobox is switched into 'focused' state,
    main component is updated); othewise the choice is not applied and
    combobox remains in 'active' state.

    'apply_action' - if specified, it is executed after changes are
    applied. The action execution status is ignored.

Text field
~~~~~~~~~~

Data:
    class GuiTextFieldDef
    {
        String initial_value; // Optional, default = null (first)
        Boolean numeric; // Optional, default = false
        Boolean password; // Optional, default = false
        Boolean has_osk; // Optional, default = false
        Boolean always_active; // Optional, default = false
        int width; // optional; default = -1 (auto)
        GuiAction confirm_action; // optional; default = null (none)
        GuiAction apply_action; // optional; default = null (none)
    }

Details:
    GUI text field is painted as standard Dune text field. It can reside in
    states:
        - unfocused: text field painted without focus;
        - focused: text field painted with focus; ENTER key is
          intercepted to switch to the active state;
        - active; text field painted with focus and some additional
          graphics; the arrow keys, ENTER, RETURN and some other keys are
          intercepted.

Parameters:
    'initial_value' - the initial string.

    'numeric' - if true => only number characters can be added;

    'pasword' - if true => all characters are visualized as '*';

    'has_osk' - if true => the on-screen keyboard is painted under the text
    field; NOTE: currenly the OSK height is not taken into account when
    components are layouted; so one should add VGapis to achieve nice
    looking of container.

    'always_active' - if true => the 'focused' state of text field is
    avoided, i.e. text field is automatically switched to 'active' state
    when it gains focus.

    'width' - the width of text field; if not specified => some predefined
    width is used.

    'confirm_action' - if specified, it is executed when user press ENTER
    in the active state of control. During confirm_action's execution the
    changes in text string are not applied and text field remains in
    'active' state. If execution status is OK => changes are applied and
    text field is switched to 'focused' state; othewise the changes are
    reverted and text field remains in 'active' state.

    'apply_action' - if specified, it is executed after changes are
    applied. The action execution status is ignored.

Button
~~~~~~

Data:
    class GuiButtonDef
    {
        String caption;
        int width; // optional; default = -1 (auto)
        GuiAction push_action; // optional; default = null (none)
    }

Details:
    GUI button is painted as standard Dune button. It can reside in
    states:
        - unfocused: button painted without focus;
        - focused: button painted with focus; ENTER key is
          intercepted to execute the push_action;

Parameters:
    'capiton' - the text over the button;

    'width' - the width of button; if not specified => the default width
    is used;

    'push_action' - if specified, it is executed when user press ENTER on
    focused button.

VGap
~~~~

Data:
    class GuiVGapDef
    {
        int vgap;
    }

Details:
    This pseudo-control is used to change the default distances between GUI
    controls. It is not painted at all.

Parameters:
    'vgap' - the integer value to be added to the default distance between
    neighbour controls. If positive => distance increased, if negative =>
    distance reduced.

Gui action execution in GUI control containers
----------------------------------------------

Every action executed from GUI control takes additional parameters in the
'params' key-value maps

The value of 'selected_control_id' is set to GuiControlDef::name of the currently
selected control. This control is always the action producer.

For each GUI control of type (combobox | text_field) the value of
'GuiControlDef::name' is set to the current state-value of this control.
The state-value of text field is the current state of edited text; the
state-value of comobox is the currently selected choice_value.

Actually, the only GUI action which is used in GUI control containers is
HANDLE_USER_INPUT. When plugin creates HANDLE_USER_INPUT action to be
assigned to some GUI control, it should preliminary add some additional
marks to 'params' map in order to be able to further recognize the context
of action invocation from the implementation of Handle_user_input()
operation. So, the implementation of Handle_user_input() can distinguish
the different GUI control containers and have all information about the
current state of all GUI controls in the current container.

Preinstalled plugin resources
-----------------------------

- Each plugin's installation may contain some resources (images). These
  images may be accessed using special url syntax:

  plugin_file://path/to/resource
  or
  plugin_file://%plugin_name%/path/to/resource

  The 1st syntax accesses the resources of the 'current' plugin
  (context-dependent).
  The 2nd syntax allows to use preinstalled resources of plugin with
  specified name.

Plugin archives
---------------

- Currently there is a way of caching the images used for representation of
  plugin menu folders in the system storage or flash memory storage
  (if supported). The PluginFolderView and PluginTvInfo may have the
  'archive' field of type PluginArchiveDef:
  {
    string $id;
    map(string,string) $urls_with_keys;
    string $all_tgz_url; // optional
    long long total_size;
    # etc..
  }

  So if one does NOT use plugin archive for folder, it leaves the
  PluginFolderView::archive as null, and writes the http://xxx/yyy.png
  image url to the corresponding ViewItemParams::icon_path. In this case,
  image will be http-downloaded many times.

  To use plugin archive, one should specify as PluginFolderView::archive:
    array(
      'id' => 'myarchive',
      'urls_with_keys' =>
        array(
          'xxx_key.png' => 'http://xxx/yyy.png',
          # etc
        ),
      'all_tgz_url' => 'http://xxx/all.tgz', // optional
      'total_size' => '1234567',
        )
  and use special syntax for ViewItemParams::icon_path:
    plugin_archive://myarchive/xxx_key.png

  The execution of the PLUGIN_OPEN_FOLDER/PLUGIN_TV_PLAY operation first
  checks whether archive is specified and launches the 'Update Archive'
  dialog if needed. The Update Archive dialog checks whether archive is
  changed. Then it checks whether suitable storage exists and has enough
  free space. Then it and performes synchronization of the remote archive
  state with local cache (the extra files are deleted, missing files are
  downloaded). The keys are used as file names in the local cache. The
  'total_size' value is trusted to be the cumulated size of all files in
  archive.

  The files can be downloaded by 2 different methods:

    - first, if number of images to download is more than some limit (now
      50) => then gzipped tarball is downloaded from 'all_tgz_url' URL,
      unpacked and used as new local cache. The tarball's content should be
      consistent with keys of the 'urls_with_keys' map: it should contain
      the same set of files.

    - Otherwise (if < 50 files have to be downloaded or 'all_tgz_url' is
      unset) => the needed files are downloaded from their remote locations
      specified in 'urls_with_keys'.

  The handling of the icon URLs of type 'plugin_archive://<archive>/<key>'
  work correctly even when Dune GUI was unable to keep local copy of
  archive. In this case plugin_archive:// URLs work as http:// URLs.

Asynchronous image loading
--------------------------

The asynchronous image loading is used in regular folders with
FolderViewParams::async_icon_loading == true.
If async_icon_loading == false then GUI is blocked until all visible icons
are loaded.
If async_icon_loading == true then icon files are downloaded in separate
thread. During the download process the
PluginRegularFolderView::not_loaded_view_item_params is used for
representing the element and therefore another image may be used instead.
NOTE: some image resources are never loaded asynchronously:
  1. standard Dune skin resources, e.g. urls gui_skin://xxx
  2. preinstalled plugin resources, e.g. urls plugin_file://xxx
  3. resources from the already cached plugin archive, e.g.
     urls plugin_archive://<archive_name>/path

Plugin TV archive playback
--------------------------

Each plugin TV channel may have support for archive playback.

To enable archive playback:
  - PluginTvChannel::have_archive should be set to true;
  - Get_tv_playback_url() + Get_tv_stream_url() should accept real
    unixtime values of 'archive_tm_sec' parameter and return the correct
    archive stream URL;
  - archive_past_days and archive_delay_sec of PluginTvChannel should be
    set appropriately. The default is 14 days and 31 minutes
    correspondingly.

Protected TV channels
---------------------

Currently the only way to enable the protect code checking for some
channels one should do the following:
  - set PluginTvChannel::is_protected to true;
  - set PluginTvChannel::playback_url_is_stream_url to false if not done
    yet;
  - encode given protect_code into the result playback_url in the
    implementation of Get_tv_playback_url();
  - ensure that Get_tv_stream_url() returns string 'protected' each time the
    protect code is incorrect and the actual stream url otherwise.

Auto-resume
-----------

The auto-resume feature is enabled by setting
<auto_resume>
    <enable>yes</enable>
    ...
</auto_resume>
in the plugin manifest.

The auto-resume procedure is triggered when STB is turned on or resumed
from standby mode. This procedure tries to restore the last state of Dune
GUI before STB was turned off or sent to standby. Currently only the
following GUI states can be auto-resumed:

    - Live TV playback of the particular channel;
    - Archive TV playback of the particular channel and timestamp.
    - VOD playback of the particular movie.

NOTE: the position of Dune GUI in folder hierarchy is not remembered now
and therefore cannot be restored.

It is possible to add the standard IP address and valid time requirements
for the auto-resume:
<auto_resume>
    ...
    <ip_address_required>yes</ip_address_required>
    <valid_time_required>yes</valid_time_required>
</auto_resume>

Also there is a way to specify custom GUI action to be executed instead of
the default auto-resume procedure. Example:
<auto_resume>
    <enable>yes</enable>
    <action>
        <type>plugin_handle_user_input</type>
    </action>
</auto_resume>
The all values of the resume_state.properties will be passed to the
auto-resume actions as parameters.

Including executable Linux programs into plugin
-----------------------------------------------

If plugin archive contains 'bin' directory (at the same level as the plugin
manifest), all files and subdirectories in the 'bin' directory will be made
executable during installation. In other words, if the plugin needs
executable files, they should be put under the 'bin' directory. Note, that
ZIP-archives don't support UNIX file attributes, thus, even if an archive
has been created from the executable files, those files will not have
executable attribute after extracting from the archive.

Interface language translations
-------------------------------

Each plugin may provide additional local translation tables located in
$install_dir_path/translations directory and having names
dune_language_<lang>.txt. These files will be loaded to the global STB
translation table on STB start or when interface language is changed by
user.

The local plugin translation files have the same format as global Dune
translation files. They define additional keys to be added to the global
table. The local translation keys are added to the plugin's own namescope
and cannot conflict with the global keys. Only the owner plugin can access
translation keys provided by itself.

The translation keys can be used in so-called public strings. Such strings
can be:
1. returned from DunePlugin interface calls;
2. declared in dune_plugin.xml.
Public strings are easily recognized: they are intended to be painted on
screen in some use-cases. For example, the plugin caption, entry point
caption, and all other "captions" are the public strings.

Each public string may be:
1. Just fixed string (not translated)
    "Movie"
2. Simple reference:
    "%tr%movie_caption"
   For example, if current interface language is "english" and plugin has
   the following record in it's translations/dune_language_english.txt:
    movie_caption = Movie
   and another on in translations/dune_language_french.txt:
    movie_caption = Film
   then this string will be dereferenced to
    "Movie" or "Film" depending on current interface language setting.
3. Extended public string syntax:
    extended_public_string ::= "%ext%" string_with_refs
    string_with_refs ::= string {ref string}
    ref ::= "<key_local>" key_name {param} "</key_local>"
    param ::= "<" param_name ">" string_with_refs "</" param_name ">";
    key_name ::= string
    param_name ::= string
   Examples:
    1) Using of positional parameters:
       String:
        "%ext%<key_local>movie_folder_contains__1<p>20</p></key_local>"
       Translation record:
        movie_folder_contains__1 = Folder contains %s movies.
       Result string:
        "Folder contains 20 movies."
    2) Using of named parameters:
       String:
        "%ext%<key_local>cur_time3<h>21</h><m>38</m><s>00</s></key_local>"
       Translation record:
        cur_time3 = Current time is ${h}:${m}:${s}.
       Result string:
        "Current time is 21:38:00."

HTTP server extension
---------------------

The local STB HTTP server is configured to provide access to files in the
following directories in plugin file structure:
    $install_dir_path/www/*           - normal access;
    $install_dir_path/www/cgi-bin/*   - access with CGI execution enabled.
The following HTTP urls are mapped to these directories:
    http://<STB-address>/plugins/<plugin_name>/*
    http://<STB-address>/cgi-bin/plugins/<plugin_name>/*
The following language constructions are provided for convenience in PHP
code:
DuneSystem::$properties['plugin_www_url'] =
        http://127.0.0.1/plugins/<plugin_name>/
DuneSystem::$properties['plugin_cgi_url'] =
        http://127.0.0.1/cgi-bin/plugins/<plugin_name>/

Auto-start
----------

The auto start specification in the plugin manifest dune_plugin.xml is
used only when plugin is marked as "main" plugin for the current firmware
build. There can be <=1 "main" plugin in system.

The auto_start section in plugin manifest affects the use-cases:
    - STB power-on;
    - resume from the stand-by mode.

For "main" plugin the <auto_start> section in dune_plugin.xml is taken into
account; the <auto_start> section of other plugins is just ignored. The
example of the auto_start section:

<dune_plugin>
  ...
  <auto_start>
    <entry_point_media_url>main_tv</entry_point_media_url>
    <action>
        <type>plugin_open_folder</type>
    </action>
  </auto_start>
  ...
</dune_plugin>

This specification will cause STB to enter the "main_tv" plugin folder on
each startup (of course, if the described plugin is "main" plugin).

Details:

    - entry_point_media_url (optional, default = unset)
        the media_url of the plugin entry point. On STB startup the folder
        containing the specified entry point will be entered and the entry
        point itself will be focused. If not set, the default folder will
        be opened on startup.

    - action (optional, default = unset)
        the action to be executed on startup (just after entry point is
        selected, if specified).

    - ip_address_required = yes|no (optional, default = no)
    - valid_time_required = yes|no (optional, default = no)
        if yes, the standard dialog will appear waiting for IP address or
        valid  time.

    - run_action_before_auto_resume = yes|no (optional, default = no)
        By default, the auto-start action will not be executed when STB
        tries to auto-resume playback. Setting the
        'run_action_before_auto_resume' to 'yes' will force STB to execute
        auto-start action even in the auto-resume use-case. See the details
        about the auto-resume feature in the corresponding section
        ('Auto-resume').

    - skip_initial_dialogs = yes|no (optional, default = no)
        if yes, the action will be executed before the initial STB setup
        wizard; otherwise action will be executed after setup wizard. This
        only affects the use-case of first STB power-on after
        the Reset Settings procedure.

    - force_on_start = none|main_screen|black_screen
    - force_on_finish = none|main_screen|black_screen
        allows to specify the background for auto_start action execution.

Image file formats (for icons etc)
----------------------------------

- JPEG
- PNG with alphachannel
- BMP with alphachannel
- AAI with alphachannel
   - This is Dune HD proprietary format.
   - See:
      - http://dune-hd.com/firmware/misc/
      - http://dune-hd.com/firmware/misc/AAImageGen-README.txt

Ways to reference image files from plugins
------------------------------------------

- Image file from web server:
   - Icon path/URL: http://host[:port][path]

- Image file from web server, preloaded/cached via plugin archive:
   - Icon path/URL: plugin_archive://archive-name/path

- Image file built-in into plugin (part of plugin):
   - Icon path/URL: plugin_file://path-to-file
   - Example: plugin_file://plugin_icon.png

- Image file built-in into firmware (part of standard GUI skin):
   - Icon path/URL: gui_skin://path-to-file
   - Example: gui_skin://large_icons/tv.aai
   - More information about GUI skins:
      - http://dune-hd.com/support/skins

Features added in firmware version 120531_2200_beta
---------------------------------------------------

Starting with the firmware version 120531_2200_beta, the following Dune PHP
Plugins API extensions and improvements were added:
   - New GUI actions:
      - file_play
      - dvd_play
      - bluray_play
      - playlist_play
      - launch_media_url
      - change_behavior
      - show_black_screen
      - show_main_screen
   - New GUI events:
      - timer
      - playback_stop
   - New properties in existing data structures:
      - GuiAction::params
      - PluginInvalidateFoldersActionData::details
      - PluginInvalidateFoldersActionData::rate_details
      - PluginMovieFolderView::left_button_caption
      - PluginMovieFolderView::left_button_action
      - PluginMovieFolderView::params
      - PluginRegularFolderView::timer
      - PluginTvInfo::epg_mode
      - PluginVodInfo::initial_position_ms
      - PluginVodInfo::advert_mode
      - PluginVodInfo::actions
      - PluginVodInfo::timer
      - ShowDialogActionData::actions
      - ShowDialogActionData::timer
      - ShowDialogActionData::max_height
      - ShowDialogActionData::initial_sel_ndx
      - ViewItemParams::item_caption_color
      - ViewItemParams::item_sandwich_icon_scale_factor
      - ViewParams::paint_details_box_background
      - ViewParams::help_line_text_color
      - ViewParams::item_detailed_info_title_color
      - ViewParams::item_detailed_info_text_color
   - New data structures and their properties:
      - BlurayPlayActionData::url
      - ChangeBehaviourActionData::actions
      - ChangeBehaviourActionData::timer
      - ChangeBehaviourActionData::post_action
      - DvdPlayActionData::url
      - FilePlayActionData::url
      - GuiTimerDef::delay_ms
      - LaunchMediaUrlActionData::url
      - LaunchMediaUrlActionData::post_action
      - PlaylistPlayActionData::url
      - PlaylistPlayActionData::start_index
      - PluginFolderViewParams::paint_path_box
      - PluginFolderViewParams::paint_content_box_background
      - PluginFolderViewParams::background_url
      - PluginVodPlayActionData::vod_info
      - ShowBlackScreenActionData::post_action
      - ShowMainScreenActionData::post_action
   - New features related to plugin file structure:
      - {plugin_install_dir}/bin/
         - The player automatically sets executable permissions on all
           files in this directory during plugin installation.
      - {plugin_install_dir}/www/{path}
         - The player automatically makes these files accessible via
           HTTP (locally inside the player, and from the local network):
            - http://localhost-or-dune-ip-address/plugins/{plugin_name}/{path}
      - {plugin_install_dir}/www/cgi-bin/{path}
         - The player automatically makes these CGI applications
           accessible via HTTP (locally inside the player, and from the
           local network):
            - http://localhost-or-dune-ip-address/cgi-bin/plugins/{plugin_name}/{path}
   - Other new features:
      - Ability to package FlashLite application into plugin and launch
        it when the user enters plugin entry point, or when PHP plugin
        code decides to call it. Supported via the new "launch_media_url"
        action.
      - Ability to package HTML page/application into plugin and launch
        it in web browser when the user enters plugin entry point, or
        when PHP plugin decides to call it. Supported via the new
        "launch_media_url" action.
      - If the plugin is pure FlashLite or HTML application and does not
        need to execute any PHP code, "plain" plugin type can be
        specified in plugin manifest instead of "php"; in this case,
        there is no need to include PHP program into the plugin and
        specify "program" parameter in plugin manifest.

Implementing advanced playback control in PHP plugins
-----------------------------------------------------

The following features of PHP API (introduced in firmware version
120531_2200_beta) can be used to implement advanced playback control use
cases in PHP plugins.

   PluginVodInfo::timer
   PluginVodInfo::initial_position_ms
   PluginVodInfo::advert_mode
   GUI_EVENT_TIMER
   GUI_EVENT_PLAYBACK_STOP

Examples:

1) Playback AD video before and after main video.

   First perform PluginVodPlay action with media_url pointing to AD
   pre-roll video, PluginVodInfo::advert_mode == TRUE, and
   GUI_EVENT_PLAYBACK_STOP event registered in PluginVodInfo::actions.

   When GUI_EVENT_PLAYBACK_STOP event occurs, another PluginVodPlay action
   should be performed: media_url pointing to main video,
   PluginVodInfo::advert_mode == FALSE, and GUI_EVENT_PLAYBACK_STOP event
   registered in PluginVodInfo::actions.

   When GUI_EVENT_PLAYBACK_STOP event occurs, another PluginVodPlay action
   should be performed: media_url pointing to AD post-roll video,
   PluginVodInfo::advert_mode == TRUE.

   The following plugin demonstrates this approach:
      dune_plugin_demo2_with_ad.zip

2) Playback AD video in the middle of main video.

   There is no direct support for this, but the following approach can be
   potentially used (not really tested, but should work if there are no
   bugs).

   Start main video playback with PluginVodInfo::timer specified with
   appropriate timer delay (one second or a few seconds), and
   GUI_EVENT_TIMER registered in PluginVodInfo::actions.

   When GUI_EVENT_TIMER event occurs, the plugin code should check the
   current playback position, and, if needed (it is time to show ad),
   request playback of AD media url: perform PluginVodPlay action with
   PluginVodInfo::advert_mode == TRUE and GUI_EVENT_PLAYBACK_STOP event
   registered in PluginVodInfo::actions.

   When GUI_EVENT_PLAYBACK_STOP event occurs, another PluginVodPlay action
   should be performed: media_url pointing to main video,
   PluginVodInfo::advert_mode == FALSE, and
   PluginVodInfo::initial_position_ms pointing to the position where the
   main video was interrupted by the ad.

   Checking the current playback position can be performed in the following
   way:
      Read "playback_position" field in the file
      "/tmp/run/ext_command.state".
      NOTE: this is not part of official PHP API, but can be used as a
      temporary solution.

3) Rememebering and resuming VOD playback position.

   Approach A:
   ~~~~~~~~~~~

   Specify "auto_resume" feature in plugin manifest.

   If "action" is not specified, PHP engine will automatically resume VOD
   playback.

   If "action" is specified (required if PHP plugin needs to do some
   checking/processing before resuming VOD playback), see Approach B.

   Approach B:
   ~~~~~~~~~~~

   Specify "auto_resume" feature in plugin manifest, and specify
   PluginHandleUserInputAction "action".

   Instead of standard auto resume processing, the specified action will be
   executed.

   Then, in PHP code, read the information required for auto-resume from
   the following file:
      /config/resume_state.properties

      NOTE: this is not part of official PHP API, but can be used as a
      temporary solution.

      Sample content of this file:
         mode = PLUGIN_VOD_PLAYBACK
         plugin_name = some_plugin
         plugin_entry_media_url = vod_category_list
         plugin_media_url = {"screen_id":"vod_scene_info","scene_id":"193115"}
         plugin_vod_id = 193115
         plugin_vod_series_ndx = 0
         plugin_vod_position_seconds = 37
         plugin_tv_group = 1
         plugin_tv_channel = 5
         plugin_tv_is_favorite = 0
         plugin_tv_archive_tm = 1343834591

   Then, perform VOD playback with PluginVodInfo::initial_position_ms
   specified.

   Approach C:
   ~~~~~~~~~~~

   The same as Approach B, but w/o using "auto_resume" feature in plugin
   manifest. The file "/config/resume_state.properties" is created by the
   system even if "auto_resume" feature is not used, and this file can be
   read and handled by PHP plugin code.

   Approach D:
   ~~~~~~~~~~~

   Start main video playback with PluginVodInfo::timer specified with
   appropriate timer delay (one second or a few seconds), and
   GUI_EVENT_TIMER registered in PluginVodInfo::actions, and
   GUI_EVENT_PLAYBACK_STOP registered in PluginVodInfo::actions.

   When GUI_EVENT_TIMER event occurs, the plugin code should check the
   current playback position and remember it.
   (See above for the info how to do it.)

   When GUI_EVENT_PLAYBACK_STOP event occurs, the plugin code should
   persistently remember the latest playback position remembered when
   handling GUI_EVENT_TIMER events.

   Then, use the persistently remembered position when starting playback
   next time, by specifying PluginVodInfo::initial_position_ms.

Global plugin actions
---------------------

The mechanism of "global plugin actions" allows a plugin to force the STB to
perform certain actions (e.g. launch a shell script shipped within a
plugin) on certain system events (e.g. on STB boot or plugin
install/uninstall).

This mechanism was introduced in the firmware version 130515_2104_b6.

Supported system events:
   boot
      Is launched during STB boot.
   install:
      Is launched immediately after plugin has been installed.
   update:
      Is launched immediately after plugin has been updated.
   uninstall:
      Is launched before plugin is deleted.

To perform an action on a system event, the plugin should declare
corresponding global action in the plugin manifest file. The action can be
any standard plugin GUI action, or "plugin_system" action which allows to
launch an executable file shipped within the plugin. For "boot" system
event, only "plugin_system" action is supported.

Example of defining global actions in the plugin manifest file:
   <dune_plugin>
   ...
     <global_actions>
       <boot>
         <type>plugin_system</type>
         <data>
           <run_string>bin/smbserver_ctl.sh start &amp;</run_string>
         </data>
       </boot>
       <install>
         <type>plugin_system</type>
         <data>
           <run_string>bin/smbserver_ctl.sh start &amp;</run_string>
         </data>
       </install>
       <update>
         <type>plugin_system</type>
         <data>
           <run_string>bin/smbserver_ctl.sh start &amp;</run_string>
         </data>
       </update>
       <uninstall>
         <type>plugin_system</type>
         <data>
           <run_string>bin/smbserver_ctl.sh stop &amp;</run_string>
         </data>
       </uninstall>
     </global_actions>
   ...
   </dune_plugin>